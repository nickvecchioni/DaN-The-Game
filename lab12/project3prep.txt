Q: Can you think of an analogy between the process of tesselating hexagons and randomly generating a world using rooms and hallways? 
What is the hexagon and what is the tesselation on the Project 3 side?

A: Tessalating hexagons is like learning how to ride a bike. Randomly generating a world is like participating
in the X-Games. The hexagon is the equivalent of the rooms and hallways on the Project 3 Side.

-----
Q: If you were to start working on world generation, what kind of method would you think of writing first? 
Think back to the lab and the process used to eventually get to tesselating hexagons.

A: I'd probably start by writing a helper method to generate rooms and/or hallways. Like the hexagon example
we did for Lab 12, we started by figuring out how to build basic hexagons. Then, we moved onward to create a
tessalation of hexagons - much like we will do in Project 3!

-----
Q: What distinguishes a hallway from a room? How are they similar?

A: A hallway is like a path - it is narrow and and spans from one room to another (or from a room to another
hallway). They are similar in that both are made of the same tiles and can be explored by our user.

-----
Q: For tesselating hexagons, one of the hardest parts is figuring out where to place each hexagon/how to easily place hexagons on screen in an algorithmic way. 
After looking at your own implemention, consider the implementation provided near the end of the lab. 
How did your implementation differ from the given one? What lessons can be learned from it?

A: My implementation was fairly similar to the one provided in the spec. However, I had multiple methods to
draw out each column, which in hindsight is excessive and inelegant. Moreover, I believe that my solution only
works for hexagons of size 3 (which I could easily remedy but don't have time). It's really cool to see how
there are different approaches to solving the same problem though!

-----
Q: Consider an algorithm for placing rooms and hallways on your map. 
Ideally, consider many algorithms and think about what makes some easier or harder to implement. Try and bring those ideas together into a single simple algorithm which accomplishes the task. 
In general, algorithms with as few edge cases as possible are better algorithms.

A: I don't have an answer for this quite yet! But, I will think about it heavily over the next few days.
